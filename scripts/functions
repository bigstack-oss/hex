# HEX SDK

# PROG must be set before sourcing this file
if [ -z "$PROG" ] ; then
    echo "Error: PROG not set" >&2
    exit 1
fi

# Use /tmp unless HEX_TMPDIR is set
HEX_TMPDIR=${HEX_TMPDIR:-/tmp}

# Set HEX_DEBUG to include "trace" or "<PROG>_trace" to enable script tracing
# Set HEX_DEBUG to include "verbose" or "<PROG>_verbos" to enable echoing script as it executes
# Set HEX_DEBUG to include "debug" or "<PROG>_debug" to enable debug messages
# Set HEX_DEBUG to include "nocleanup" or "<PROG>_nocleanup" to keep temporary files after script exit
if echo "$HEX_DEBUG" | grep -w "trace\|${PROG}_trace" >/dev/null 2>&1 ; then
    set -x
fi
if echo "$HEX_DEBUG" | grep -w "verbose\|${PROG}_verbose" >/dev/null 2>&1 ; then
    set -v
fi
if echo "$HEX_DEBUG" | grep -w "debug\|${PROG}_debug" >/dev/null 2>&1 ; then
    HEX_DEBUGMSG=1
else
    HEX_DEBUGMSG=0
fi
if echo "$HEX_DEBUG" | grep -w "nocleanup\|${PROG}_nocleanup" >/dev/null 2>&1 ; then
    HEX_CLEANUP=0
else
    HEX_CLEANUP=1
fi

if echo "$HEX_DEBUG" | grep -w "usetemp\|${PROG}_reusetemp" >/dev/null 2>&1 ; then
    HEX_USETEMP=1
else
    HEX_USETEMP=0
fi

# Emit debug message to stderr
Debug()
{
    [ $HEX_DEBUGMSG -eq 0 ] || echo "$*" >&2
}

# Emit error message to stderr and exit with non-zero status
Error()
{
    echo "$PROG: Error: $*" >&2
    exit 1
}

# Emit warning message to stderr
Warning()
{
    echo "$PROG: Warning: $*" >&2
}

isElf() { /usr/bin/readelf -h "$1" >/dev/null 2>&1 ; return $? ; }

# Usage: TEMP=$(MakeTemp)
# Call RemoveTempFiles on exit to cleanup
MakeTemp()
{
    mktemp ${HEX_TMPDIR}/${PROG}$$.XXXXXX
}

# Usage: TEMP=$(MakeTempDir)
# Call RemoveTempFiles on exit to cleanup
MakeTempDir()
{
    mktemp -d ${HEX_TMPDIR}/${PROG}$$.XXXXXX
}

# Remove all files/directories created by MakeTemp and MakeTempDir
# Usage: RemoveTempFiles
RemoveTempFiles()
{
    if [ $HEX_CLEANUP -eq 0 ] ; then
        Warning "Temporary files not removed:"
        echo ${HEX_TMPDIR}/${PROG}$$.* >&2
    else
        rm -rf ${HEX_TMPDIR}/${PROG}$$.*
    fi
}

# Default cleanup function unless overridden
trap RemoveTempFiles INT TERM EXIT

# Execture a shell command and suppress it's stdout/stderr except when HEX_DEBUG is set or exit status is non-zero
# Return exit status of shell command
# Usage: Quiet [-n] <cmd> <arg> ...
# -n    Ignore exit status
Quiet()
{
    local IGNORE_ERR
    local STATUS
    local TEMP

    TEMP=$(MakeTemp)
    IGNORE_ERR=0
    if [ "$1" = "-n" ] ; then
        IGNORE_ERR=1
        shift 1
    fi
    if eval $* >$TEMP 2>&1 ; then
        STATUS=0
    else
        STATUS=$?
    fi
    [ $IGNORE_ERR -eq 0 ] || STATUS=0
    [ $STATUS -eq 0 -a -z "$HEX_DEBUG" ] || cat $TEMP >&2
    rm -f $TEMP

    return $STATUS
}

# Setup a loop device on an image with an optional offset.
# Usage: LOOPDEV=$(SetupLoop <img>)
#    or  LOOPDEV=$(SetupLoop -o <offset> <img>)
SetupLoop()
{
    local LOOPDEV=$(losetup -f 2>/dev/null || true)
    if [ -n "$LOOPDEV" -a -e "$LOOPDEV" ] ; then
        # Mounting signed PPUs/Fixpacks causes losetup to complain about not fitting into a 512-byte sector so redirect stdout/stderr
        Quiet losetup $LOOPDEV $* || Error "Failed to setup loop device"
    else
        Error "No more free loop devices"
    fi
    echo $LOOPDEV
}

# Release loop back device
# Usage: RemoveLoop <loop-dev>
RemoveLoop()
{
    sync
    if [ -n "$1" ] ; then
        [ -z "$(losetup $1 2>/dev/null)" ] || losetup -d $1
    fi
}

# Unmount and release loop back device
# Usage: UnmountRemoveLoop <loop-dev>
UnmountRemoveLoop()
{
    for ldev in $* ; do
        local i=0;
        local MNTDIR=$(mount | grep "^$ldev" | awk '{print $3}')
        if [ -n "$MNTDIR" ] ; then
            while [ $((i++)) -lt 3 ] ; do
                sync
                if umount $MNTDIR >/dev/null 2>&1 ; then
                    break
                else
                    sleep 1
                fi
            done
        fi
        umount $ldev >/dev/null 2>&1 || true
        RemoveLoop $ldev
    done
}

# Return size of a directory in kilobytes
# Usage: ComputeDiskUsage <dir>
ComputeDiskUsage()
{
    local B=$(du -sb $1 | cut -f 1)
    echo $(expr \( $B + 1023 \) / 1024 )
}

# Convert an image size folllowed by M or G suffix to kilobytes
# Usage: ConvertImageSize <img-size>
ConvertImageSize()
{
    local N
    local R

    N=$(echo $1 | sed 's/[MGKmgk]//')
    case $1 in
        *[Mm]) R=$(expr $N \* 1024) ;;
        *[Gg]) R=$(expr $N \* 1024 \* 1024) ;;
        *)     R=$N ;;
    esac

    echo $R
}

# Add overhead for filesystem and round image size up to the nearest 4k block
# Usage: AddFsOverhead <img-fmt> <img-size>
# <img-fmt>     Image format: ext2, ext4, or vfat
# <img-size>    Image size in kilobytes unless followed by M or G
AddFsOverhead()
{
    local IMG_FMT=$1
    local IMG_SIZE=$2

    # Note: These values were calculated by test_fs_overhead
    case "$IMG_FMT" in
        ext2|ext4)
            # Ext2/4 requires approx 5.2% overhead
            IMG_SIZE=$(( $(ConvertImageSize $IMG_SIZE) * 1052 / 1000 ))
            ;;
        vfat|efi)
            # Vfat requires approx 1.2% overhead
            IMG_SIZE=$(( $(ConvertImageSize $IMG_SIZE) * 1012 / 1000 ))
            ;;
        *)
            Error "Unsupported image type"
            ;;
    esac

    # Round to nearest 4k boundary
    # Kernel may need this for ramdisks
    IMG_SIZE=$(( ( ( $IMG_SIZE + 3 ) / 4 ) * 4 ))

    echo $IMG_SIZE
}

# Format an image mounted on the loop device $LOOPDEV.
# Usage: FormatImage <img-fmt> <loop-dev> [ <block-count> ]
# <img-fmt>     Image format: ext2, ext4, or vfat
FormatImage()
{
    local IMG_FMT=$1
    local LOOPDEV=$2
    local BLOCKS=$3
    case "$IMG_FMT" in
        vfat|efi)
            Quiet mkfs.vfat -F 32 $LOOPDEV $BLOCKS
            ;;
        ext2)
            # Disable root user reserved blocks
            Quiet mkfs.ext2 -m 0 $LOOPDEV $BLOCKS
            # Disable fsck
            Quiet tune2fs -c -1 -i 0 $LOOPDEV
            ;;
        ext4)
            # Disable journaling and root user reserved blocks
            # enable lazy itable init to speed mkfs up, inodes will be clearned on next mount
            Quiet mkfs.ext4 -O ^has_journal -E lazy_itable_init=1 -m 0 $LOOPDEV $BLOCKS
            # Disable fsck
            Quiet tune2fs -c -1 -i 0 $LOOPDEV
            ;;
        *)
            Error "Unsupported image type"
            ;;
    esac
}

# Create a formatted filesystem image (e.g. ramdisk, install bundle).
# NOTE: This is not a disk image. There is no partition table.
# Usage: CreateFsImage <img-fmt> <img-size> <img> [ <size-file> ]
# <img-fmt>     Image format: ext2, ext4, or vfat
# <img-size>    Image size in kilobytes unless followed by M or G
# <img>         Path to image file
# <size-file>   Path to file to hold final image size in kilobytes
CreateFsImage()
{
    local IMG_FMT=$1
    local IMG_SIZE=$2
    local IMG=$3
    local SIZE_FILE=$4

    # Create raw image file
    local RAW_SIZE=$(AddFsOverhead $IMG_FMT $IMG_SIZE)
    Quiet qemu-img create -f raw $IMG ${RAW_SIZE}K
    [ -z "$SIZE_FILE" ] || echo $RAW_SIZE >$SIZE_FILE

    # Format image file
    # Run in a subshell so that we can register our own trap to release the loop device
    # in case we get interrupted
    (
        trap 'eval RemoveLoop $LOOPDEV' INT TERM EXIT
        local LOOPDEV=$(SetupLoop $IMG)
        FormatImage $IMG_FMT $LOOPDEV
    )
}

# Create virtual OVA image
# Usage: CreateOva <raw-image> <ovf-template> <ova-file> [ <basename> ]
# <raw-image>       Raw disk image
# <ovf-template>    OVF template
# <ova-file>        Output OVA file
# <basename>        Basename. Optional. If not present, calculated from <ova-file>.
CreateOva()
{
    local RAW=$1
    local OVF_TEMPLATE=$2
    local OVA=$3
    local BASE=$4
    [ -n "$BASE" ] || BASE=$(basename $OVA .ova)

    local OVA_TEMPDIR=$(MakeTempDir)
    local OVF=$OVA_TEMPDIR/${BASE}.ovf
    local MF=$OVA_TEMPDIR/${BASE}.mf
    local VMDK=$OVA_TEMPDIR/${BASE}-disk1.vmdk

    # Size of raw image in gigabytes
    local RAW_SIZE=$(expr $(GetFileSize $RAW) / 1024 / 1024 / 1024 )

    # Convert RAW image to sparse VMDK image
    local SPARSE=$(MakeTemp).vmdk
    Quiet new-qemu-img convert -f raw -o adapter_type=lsilogic,subformat=monolithicSparse -O vmdk $RAW $SPARSE
    # Size of sparse VMDK image in bytes
    local SPARSE_SIZE=$(GetFileSize $SPARSE)

    # Convert sparse VMDK image to stream-optimized (compressed) VMDK image
    Quiet vboxmanage clonehd --format=VMDK --variant=Stream $SPARSE $VMDK
    # Size of compressed VMDK image in bytes
    local VMDK_SIZE=$(GetFileSize $VMDK)

    # Remove sparse file as soon as possible to save on space
    rm -f $SPARSE

    # Generate OVF file
    sed -e "s/@IMAGENAME@/$BASE/" \
        -e "s/@RAWSIZE@/$RAW_SIZE/" \
        -e "s/@VMDKSIZE@/$VMDK_SIZE/" \
        -e "s/@SPARSESIZE@/$SPARSE_SIZE/" \
        $OVF_TEMPLATE > $OVF

    # Generate MF (SHA1 checksums)
    for I in $OVF $VMDK ; do
        SUM=$(cat $I | sha1sum | awk '{print $1}')
        echo "SHA1($I)= $SUM"
    done > $MF

    # Generate OVA file
    # Order of OVF, MF, and VMDK matters!
    tar -H ustar -C $OVA_TEMPDIR -cf $OVA ${BASE}.ovf ${BASE}.mf ${BASE}-disk1.vmdk
    chmod 644 $OVA
}

# Wait for up to 15 seconds for udev to fire and add device
WaitForDev()
{
    for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
        if [ -b $1 -o -c $1 ] ; then
            break
        else
            sleep 1
        fi
    done
}

# Partition a hard disk into boot, swap, and A & B root partitions
# Usage: PartitionSysHDD <dev> <boot-size> <swap-size>
# Sizes are in kilobytes unless followed by M or G
PartitionSysHDD()
{
    local DEVICE=$1
    local DEV_PART=$1
    local BOOTSIZE=$(ConvertImageSize $2)
    local SWAPSIZE=$(ConvertImageSize $3)

    if [ -d /sys/firmware/efi ] ; then
        if [ $SWAPSIZE -eq 0 ] ; then
            # Create GUID partitions
            # 1: boot (EFI)
            cat <<EOF | Quiet -n fdisk $DEVICE
g
n
1

+${BOOTSIZE}KB
Y
t
1
w
EOF
        else
            # Create GUID partitions
            # 1: boot (EFI)
            # 2: swap
            cat <<EOF | Quiet -n fdisk $DEVICE
g
n
1

+${BOOTSIZE}KB
Y
t
1
n
2

+${SWAPSIZE}KB
t
2
19
w
EOF
        fi
    else
        if [ $SWAPSIZE -eq 0 ] ; then
            # Create MBR partitions
            # 1: boot
            # 2: extended: rest of disk
            cat <<EOF | Quiet -n fdisk $DEVICE
o
n
p
1

+${BOOTSIZE}KB
n
e
2


a
1
t
1
83
w
EOF
        else
            # Create MBR partitions
            # 1: boot
            # 2: swap
            # 3: extended: rest of disk
            cat <<EOF | Quiet -n fdisk $DEVICE
o
n
p
1

+${BOOTSIZE}KB
n
p
2

+${SWAPSIZE}KB
n
e
3


a
1
t
1
83
t
2
82
w
EOF
        fi
    fi

    # unit is sector (512B), divide by 2 for KB
    local SPACELEFT=$(parted $DEVICE unit KB print free | grep 'Free Space' | tail -1 | awk '{sub(/kB/, "", $3) ; print $3}')
    local MIN_HDDSIZE=$(ConvertImageSize 100G)

    if [ $SPACELEFT -lt $MIN_HDDSIZE ] ; then
        Error "minimum disk size for root partitions is 100GB"
    fi

    # production: 45%, 45%, 10%
    ROOTSIZE=$(( SPACELEFT * 45 / 100 ))

    # Create logical partitions
    # 5: system (A)
    # 6: system (B)
    # 7: store (C)
    if [ -d /sys/firmware/efi ] ; then
        cat <<EOF | Quiet -n fdisk $DEVICE
n
5

+${ROOTSIZE}KB
n
6

+${ROOTSIZE}KB
n
7


p
w
EOF
    else
        cat <<EOF | Quiet -n fdisk $DEVICE
n
l

+${ROOTSIZE}KB
n
l

+${ROOTSIZE}KB
n
l


t
5
83
t
6
83
t
7
83
p
w
EOF
    fi
    partprobe $DEVICE

    if echo $DEVICE | grep -q nvme ; then
        # nvme partition example /dev/nvme0n1p1 /dev/nvme0n1p2, ...
        DEV_PART=${DEV_PART}p
    fi

    WaitForDev ${DEV_PART}1

    if [ -d /sys/firmware/efi ] ; then
        # GPT for UEFI doesn't have logical partition
        [ $SWAPSIZE -eq 0 ] || WaitForDev ${DEV_PART}2
    else
        WaitForDev ${DEV_PART}2
        [ $SWAPSIZE -eq 0 ] || WaitForDev ${DEV_PART}3
    fi
    WaitForDev ${DEV_PART}5
    WaitForDev ${DEV_PART}6
    WaitForDev ${DEV_PART}7
}

# Prepare a disk and label it as a prepared data storage.
# E.g.: /dev/sdf1: PARTLABEL="hex_prep_f" via blkid cmd.
PrepareDataDisk()
{
    local DEVICE=$1
    local LABELNAME="hex_prep_"$(echo $DEVICE | sed 's@/dev/@@g')
    parted -s $DEVICE mklabel gpt mkpart $LABELNAME xfs 0% 100% || Error "Failed to partition disk"
    partprobe $DEVICE
}

# Partition a hard disk used for storage
# Usage: PartitionDataHDD <dev>
PartitionDataHDD()
{
    local DEVICE=$1
    parted -s $DEVICE mklabel gpt mkpart primary xfs 0% 100% || Error "Failed to partition disk"
    partprobe $DEVICE
}

# Create a single partition disk image
# Usage: PartitionDiskImage <img-fmt> <loop-dev> <cylinders>
PartitionDiskImage()
{
    local IMG_FMT=$1
    local LOOPDEV=$2
    local CYLINDERS=$3

    local IDTYPE
    case "$IMG_FMT" in
        ext2|ext4) IDTYPE=83 ;; # Linux
        vfat)      IDTYPE=e ;;  # W95 FAT16 (LBA)
        efi)       IDTYPE=ef ;;  # EFI (FAT-12/16/32)
        *)         Error "Unsupported image type" ;;
    esac

    # For more information see: http://wiki.osdev.org/Loopback_Device#Hard_Disk_Images
    cat <<EOF | Quiet -n fdisk -u -C $CYLINDERS -H 16 -S 63 -b 512 $LOOPDEV
o
c
n
p
1


t
$IDTYPE
p
w
EOF

    if [ "$IMG_FMT" == "vfat" ] ; then
        # Make partition active
        cat <<EOF | Quiet -n fdisk -u $LOOPDEV
a

p
w
EOF
    fi
}

# Return the offset to the first partition.
# Usage: PART_TABLE_SIZE=$(GetPartitionOneOffset)
GetPartitionOneOffset()
{
    # For more information see: http://wiki.osdev.org/Loopback_Device#Hard_Disk_Images

    # 63 sectors per track * 512 bytes per sector
    echo 32256
}

# Return the byte offset to a partition of a disk image.
# Usage: OFFSET=$(GetPartitionOffset <raw-image> <partition-index>)
# <raw-image>           Raw disk image file
# <partition-index>     Index of partition, starting at 1
GetPartitionOffset()
{
    # For more information see:
    # http://wiki.osdev.org/Loopback_Device#Hard_Disk_Images
    # http://www.andremiller.net/content/mounting-hard-disk-image-including-partitions-using-linux

    local IMG=$1
    local INDEX=$2

    # Use "parted" to dump parition table offsets in bytes, e.g.:
    #
    # $ parted tmp.raw unit B print
    # Model:  (file)
    # Disk tmp.raw: 8589934592B
    # Sector size (logical/physical): 512B/512B
    # Partition Table: msdos
    #
    # Number  Start        End          Size         Type      File system     Flags
    #  1      32256B       213857279B   213825024B   primary   ext4            boot
    #  2      213857280B   2319528959B  2105671680B  primary   linux-swap(v1)
    #  3      2319528960B  8587192319B  6267663360B  extended
    #  5      2319561216B  5461585919B  3142024704B  logical   ext4
    #  6      5461618176B  8587192319B  3125574144B  logical   ext4
    local OFFSET=$(parted $IMG unit B print | grep "^ $INDEX" | awk '{sub(/B/, "", $2) ; print $2}')
    echo $OFFSET
}

# Return the size of a file in bytes
# Usage: GetFileSize <file>
GetFileSize()
{
    [ -f "$1" ] && stat -c '%s' "$1" || echo 0
}

# Create a disk image containing a single formatted partition.
# Usage: CreateDiskImage <img-fmt> <img-size> <img>
# <img-fmt>     Image format: ext2, ext4, or vfat
# <img-size>    Image size in kilobytes unless followed by M or G
# <img>         Path to image file
CreateDiskImage()
{
    # For more information see: http://wiki.osdev.org/Loopback_Device#Hard_Disk_Images

    local IMG_FMT=$1
    local IMG_SIZE=$2
    local IMG=$3
    local OFFSET=${4:-$(GetPartitionOneOffset)}

    # Compute request image size in bytes including filesystem overhead and partition table
    if [ "u$IMG_FMT" = "uefi" ] ; then
        local OFFSET=0
    fi
    local IMG_BYTES=$(( ( $(AddFsOverhead $IMG_FMT $IMG_SIZE) * 1024 ) + $OFFSET ))

    # Compute number of cylinders (rounded up)
    # 516096 bytes per cylinder = 16 heads * 63 sectors * 512 bytes per sector
    local CYLINDERS=$(( ( $IMG_BYTES + 516095 ) / 516096 ))

    # Compute size of raw image in kilobytes for qemu-img (rounded up)
    local RAW_SIZE=$(( ( ( $CYLINDERS * 516096 ) + 1023 ) / 1024 ))

    # Create raw disk image
    Quiet qemu-img create -f raw $IMG ${RAW_SIZE}K

    # Partition disk image
    # Run in a subshell so that we can register our own trap to release the loop device
    # in case we get interrupted
    (
        trap 'eval RemoveLoop $LOOPDEV' INT TERM EXIT
        local LOOPDEV=$(SetupLoop $IMG)
        PartitionDiskImage $IMG_FMT $LOOPDEV $CYLINDERS
        RemoveLoop $LOOPDEV
        LOOPDEV=$(SetupLoop -o $OFFSET $IMG)
        FormatImage $IMG_FMT $LOOPDEV
    )
}

# Extract gzipped cpio archive (rootfs or initramfs)
# Usage: ExtractCgz <cgz> <dir>
ExtractCgz()
{
    local CGZ=$1
    local DIR=$2
    [ -f $CGZ ] || Error "cpio archive not found: $CGZ"
    [ -d $DIR ] || Warning "make directory: $DIR" && mkdir -p $DIR
    pigz -cd $CGZ | ( cd $DIR && cpio -iumd --quiet )
}

# Create gzipped cpio archive (rootfs or initramfs)
# Usage: CreateCgz <cgz> <dir> [<find args>]
CreateCgz()
{
    local CGZ=$1
    local DIR=$2
    local FINDARGS=$3
    [ -d $DIR ] || Error "directory not found: $DIR"
    ( cd $DIR && find ${FINDARGS:-.} | cpio -o -H newc --quiet ) | pigz -9 > $CGZ
}

# Write to stdout a list of md5sum's for all files in the directory rooted at <rootdir>
# Usage: GenRootMd5 <rootdir>
GenRootMd5()
{
    local ROOTDIR=$1
    (
        cd $ROOTDIR
        find . -type f |
            while read FILE ; do
                case "$FILE" in
                    *.debug) ;;
                    *)  if isElf "$FILE" ; then
                            # Strip build id and debuglink
                            TEMPFILE=$(MakeTemp)
                            objcopy -R .note.gnu.build-id -R .gnu_debuglink -R .rodata.str1.8 -S "$FILE" "$TEMPFILE"
                            SUM=$(md5sum "$TEMPFILE" | awk '{print $1}')
                            rm -f $TEMPFILE
                        else
                            SUM=$(md5sum "$FILE" | awk '{print $1}')
                        fi
                        # To handle files with spaces separate with colon
                        echo "$FILE:$SUM"
                        ;;
                esac
            done | sort | sed -e 's!^\./!!'
    )
}

# Return new filename to replace suffix, which indicates signature type
# Usage: ChangeFilenameSuffixSignature <file> <extension> <new-suffix>
# <extension>   Current file extension (e.g., .pkg, .pxe, .img)
# <new-suffix>  New suffix to indicate signature type (e.g., _dev, _beta, or "")
ChangeFilenameSuffixSignature()
{
    local FILE="$1"
    local EXTENSION="$2"
    local NEW_SUFFIX="$3"

    local NEW_FILE
    Debug "ChangeFilenameSuffixSignature: FILE=$FILE"
    case "$(basename "$FILE" "$EXTENSION")" in
        *_dev)
            NEW_FILE=$(echo "$FILE" | sed -e "s/_dev/$NEW_SUFFIX/")
            ;;
        *_beta)
            NEW_FILE=$(echo "$FILE" | sed -e "s/_beta/$NEW_SUFFIX/")
            ;;
        *)
            NEW_FILE=$(basename "$FILE" "$EXTENSION" | sed -e "s/\$/$NEW_SUFFIX/")"$EXTENSION"
            ;;
    esac
    Debug "ChangeFilenameSuffixSignature: NEW_FILE=$NEW_FILE"
    echo "$NEW_FILE"
}

# Rename file to replace suffix, which indicates signature type
# Usage: RenameFilenameSuffixSignature <file> <extension> <new-suffix>
# <extension>   Current file extension (e.g., .pkg, .pxe, .img)
# <new-suffix>  New suffix to indicate signature type (e.g., _dev, _beta, or "")
RenameFilenameSuffixSignature()
{
    local FILE="$1"
    local EXTENSION="$2"
    local NEW_SUFFIX="$3"

    local NEW_FILE=$(ChangeFilenameSuffixSignature $FILE $EXTENSION $NEW_SUFFIX)
    [ "$FILE" = "$NEW_FILE" ] || mv "$FILE" "$NEW_FILE"
    chmod 644 "$NEW_FILE"
    echo "$NEW_FILE"
}

# Change the "sys.build.signature" in the settings.sys file
# Usage: ChangeSettingsSysSignature <rootdir> <key-type>
# <rootdir>     Directory where rootfs is mounted/unpacked
# <key-type>    Signing key type (e.g. Developer, Beta, Release)
ChangeSettingsSysSignature()
{
    local ROOTDIR="$1"
    local KEY_TYPE="$2"

    if [ -f $ROOTDIR/etc/settings.sys ] ; then
        Debug "ChangeSettingsSysSignature: Original: $(grep ^sys.build.signature $ROOTDIR/etc/settings.sys)"
        sed -i -e "/^sys.build.signature/d" $ROOTDIR/etc/settings.sys
        echo sys.build.signature = $KEY_TYPE >> $ROOTDIR/etc/settings.sys
        Debug "ChangeSettingsSysSignature: New: $(grep ^sys.build.signature $ROOTDIR/etc/settings.sys)"
    fi
}

# Change the signature type suffix inside the /etc/release file
# Usage: ChangeReleaseFileSignature <file> <new-suffix>
# <file>        Path to /etc/release file (e.g. $ROOTDIR/etc/release, $PPUDIR/release)
# <new-suffix>  New suffix to indicate signature type (e.g., _dev, _beta, or "")
ChangeReleaseFileSignature()
{
    local FILE="$1"
    local NEW_SUFFIX="$2"

    if [ -f $FILE ] ; then
        Debug "ChangeReleaseFileSignature: Original: $(cat $FILE)"
        case "$(cat $FILE)" in
            *_dev)  sed -i -e "s/_dev/$NEW_SUFFIX/" $FILE ;;
            *_beta) sed -i -e "s/_beta/$NEW_SUFFIX/" $FILE ;;
            *)      sed -i -e "s/\$/$NEW_SUFFIX/" $FILE ;;
        esac
        Debug "ChangeReleaseFileSignature: New: $(cat $FILE)"
    fi
}

# Change the signature type inside the update.contents file
# Usage: ChangeUpdateContentsSignature <rootdir> <new-suffix>
# <rootdir>     Directory where PPU is mounted
# <new-suffix>  New suffix to indicate signature type (e.g., _dev, _beta, or "")
ChangeUpdateContentsSignature()
{
    local ROOTDIR="$1"
    local NEW_SUFFIX="$2"

    Debug "ChangeUpdateContentsSignature: Original: $(grep 'source.*pkg' $ROOTDIR/update.contents)"
    sed -i -e "s/_dev\.pkg/.pkg/" \
        -e "s/_beta\.pkg/.pkg/"  \
        -e "s/\.pkg/$NEW_SUFFIX.pkg/" $ROOTDIR/update.contents
    Debug "ChangeUpdateContentsSignature: New: $(grep 'source.*pkg' $ROOTDIR/update.contents)"
}

# Make ISO image
# Usage: MakeISO <image> <dir>
# <image>       Output ISO image
# <dir>         Directory to copy to ISO image
MakeISO()
{
    local IMG="$1"
    local TEMPDIR="$2"

    Quiet xorriso -as mkisofs -o $IMG \
          -isohybrid-mbr /usr/share/syslinux/isohdpfx.bin \
          -b isolinux/isolinux.bin \
          -c isolinux/boot.cat \
          -no-emul-boot \
          -boot-load-size 4 \
          -boot-info-table \
          -l -R -L -D -r \
          -eltorito-alt-boot \
          -e uefi.img \
          -no-emul-boot \
          -isohybrid-gpt-basdat $TEMPDIR
}

MakeDataISO()
{
    local IMG="$1"
    local TEMPDIR="$2"

    Quiet xorriso -as mkisofs -o $IMG -l -R -D -r $TEMPDIR
}

MountAndExtractCgz()
{
    local FIXPACKFILE=$1
    local TEMPDIR=$2
    local TEMPMOUNTDIR=$(MakeTempDir)
    (
        trap 'eval UnmountRemoveLoop $LOOPDEV' INT TERM EXIT
        LOOPDEV=$(SetupLoop $FIXPACKFILE)
        mount -t ext4 $LOOPDEV $TEMPMOUNTDIR
        ExtractCgz $TEMPMOUNTDIR/rootfs.cgz $TEMPDIR
    )
}

MountPkg()
{
    local PKGFILE=$1
    local DIR=$2
    [ -d $DIR ] || Warning "make directory: $DIR" && mkdir -p $DIR
    (
        LOOPDEV=$(SetupLoop $PKGFILE)
        echo run \"$PROG UnmountRemoveLoop $LOOPDEV\" after use
        mount -t ext4 $LOOPDEV $DIR
    )
}

MountImg()
{
    local IMGFILE=$1
    local DIR=$2
    local OFFSET=${3:-$(GetPartitionOneOffset)}
    [ -d $DIR ] || Warning "make directory: $DIR" && mkdir -p $DIR
    (
        LOOPDEV=$(SetupLoop -o $OFFSET $IMGFILE)
        echo run \"$PROG UnmountRemoveLoop $LOOPDEV\" after use
        mount -t vfat $LOOPDEV $DIR
    )
}

MountIso()
{
    local ISOFILE=$1
    local DIR=$2
    [ -d $DIR ] || Warning "make directory: $DIR" && mkdir -p $DIR
    (
        LOOPDEV=$(SetupLoop $ISOFILE)
        echo run \"$PROG UnmountRemoveLoop $LOOPDEV\" after use
        mount -t iso9660 $LOOPDEV $DIR
    )
}

# Usage: MountOtherPartition
# Mount inactive partition under /mnt/target
MountOtherPartition()
{
    sync
    umount /mnt/target >/dev/null 2>&1

    CURRENT="$(cat /etc/mtab | grep '^/dev' | awk '{if ($2 == "/") print $1;}')"
    case "$CURRENT" in
        *5) OTHER="$(dirname $CURRENT)/$(basename $CURRENT 5)6" ;;
        *6) OTHER="$(dirname $CURRENT)/$(basename $CURRENT 6)5" ;;
        *) echo "Error: Could not determine current default" >&2 ; exit 1 ;;
    esac

    echo "Mounting $OTHER on /mnt/target"
    mount -t ext4 $OTHER /mnt/target
}

# List all nvme* and sd* on system
ListAllDisks()
{
    for host in /sys/class/scsi_host/* ; do echo "- - -" > $host/scan ; done
    local nvmes=$(ls /dev/nvme* 2>/dev/null| grep -oe '/dev/nvme[0-9]\+n[0-9]\+$')
    local ssds=$(ls /dev/sd* 2>/dev/null| grep -oe '/dev/sd[a-z]\+$')

    local disks=
    for d in $nvmes $ssds ; do
        if lsblk -nd | grep -q "${d#/dev/}" ; then
            disks+="$d "
        fi
    done
    echo -n ${disks%% }
}

# List all mounted(in-use) disks
ListMountedDisks()
{
    local nvmes=$(findmnt | grep -oe '/dev/nvme[0-9]\+n[0-9]\+' | sort | uniq)
    local ssds=$(findmnt | grep -oe '/dev/sd[a-z]\+' | sort | uniq)
    local lvms=$(ceph-volume lvm list --format json | jq -r ".[][].devices[]" | sort | uniq)

    [ "x${nvmes}" = "x" ] || nvmes=$(readlink -e $nvmes)
    [ "x${ssds}" = "x" ] || ssds=$(readlink -e $ssds)
    [ "x${lvms}" = "x" ] || lvms=$(readlink -e $lvms)
    local disks=
    for d in $nvmes $ssds $lvms ; do
        disks+="$d "
    done
    echo -n ${disks%% }
}

# Return free sectors by given disk
GetFreeSectorsByDisk()
{
    DEVICE=$1
    TOTAL=$(sgdisk -E $DEVICE | grep -oe '^[0-9]\+$')
    OCCUP=$(sgdisk -F $DEVICE | grep -oe '^[0-9]\+$')
    AVAIL=$(( $TOTAL - $OCCUP ))
    [[ "$AVAIL" -gt 0 ]] || AVAIL=0
    echo $AVAIL
}

# Show # of partitions in a disk
ListNumOfPartitions()
{
    local DEV=$1
    echo -n $(lsblk -n $DEV | grep part | wc -l)
}

# List all prepared disks
ListPreparedDisks()
{
    local PREP_NVME_DEVS=$(readlink -e /dev/disk/by-partlabel/hex_prep* | grep -oe '/dev/nvme[0-9]\+n[0-9]\+' | sort | uniq)
    echo -n $PREP_NVME_DEVS
    if [ -n "$PREP_NVME_DEVS" ] ; then
        echo -n " "
    fi
    local PREP_SCSI_DEVS=$(readlink -e /dev/disk/by-partlabel/hex_prep* | grep -oe '/dev/sd[a-z]\+' | sort | uniq)
    echo -n $PREP_SCSI_DEVS
}

# List all free disks
ListAvailDisks()
{
    local disks_mounted=
    for d in $(ListAllDisks) ; do
        local available=true
        for b in $(ListMountedDisks) ; do
            if [ "x${d}" = "x${b}" ] ; then
                available=false
                break
            fi
        done
        [ "$available" = "false" ] || disks_available+="$d "
    done

    echo -n ${disks_available%% }
}

# List all HDDs
ListAllHDDs()
{
    for host in /sys/class/scsi_host/* ; do echo "- - -" > $host/scan ; done
    echo -n $(lsblk -n -d -o name,rota | grep "^sd" | grep 1$ | grep -oe 'sd[a-z]\+' | sed -e 's@^@/dev/@g')
}

# List all free HDDs
ListAvailHDDs()
{
    local ALL_DEVS=$(ListAllHDDs)
    local BUSY_DEVS=$(ListMountedDisks)
    local RET_DEVS=""
    for h in ${ALL_DEVS} ; do
        if [[ ${BUSY_DEVS} =~ ${h} ]] ; then
            continue
        fi
        RET_DEVS+=" $h"
    done
    echo -n ${RET_DEVS}
}

# List all SSDs
ListAllSSDs()
{
    for host in /sys/class/scsi_host/* ; do echo "- - -" > $host/scan ; done
    local nvme=$(lsblk -n -d -o name,rota | grep ^nvme | grep 0$ | grep -oe 'nvme[0-9]\+n[0-9]\+' | sed -e 's@^@/dev/@g')
    local hdd=$(lsblk -n -d -o name,rota | grep "^sd" | grep 0$ | grep -oe 'sd[a-z]\+' | sed -e 's@^@/dev/@g')
    echo -n $nvme
    if [ -n "$nvme" ] ; then
        echo -n " "
    fi
    echo -n $hdd
}

# List all free SSDs
ListAvailSSDs()
{
    local ALL_DEVS=$(ListAllSSDs)
    local BUSY_DEVS=$(ListMountedDisks)
    local RET_DEVS=""
    for h in ${ALL_DEVS} ; do
        if [[ ${BUSY_DEVS} =~ ${h} ]] ; then
            continue
        fi
        RET_DEVS+=" $h"
    done
    echo -n ${RET_DEVS}
}

ListBlkByType()
{
    local TYPE="$1"
    echo -n $(blkid | grep $TYPE | awk -F: '{print $1}' | tr '\r\n' ' ')
}

GetBlkUuid()
{
    local DEV="$1"
    echo -n $(blkid -o value -s UUID $DEV)
}

GetBlkPartUuid()
{
    local DEV="$1"
    echo -n $(blkid -o value -s PARTUUID $DEV)
}

ClearBondingSlaves()
{
    local MASTER=$1
    local cidrs=$(ip -4 addr show $MASTER | grep "^    inet .* $MASTER" | awk '{print $2}')
    local defgw=$(ip -4 route | grep "^default.*$MASTER" | awk '{print $3}')

    if [ -n "$MASTER" ] ; then
        /usr/sbin/ip link set $MASTER down
        for SLAVE in $(cat /sys/class/net/$MASTER/bonding/slaves) ; do
            RemoveBondingSlave $MASTER $SLAVE
        done
        /usr/sbin/ip link set $MASTER up

        if ! ip -4 addr show $MASTER | grep -q "inet" ; then
            for cidr in $cidrs ; do
                ip -4 addr add $cidr dev $MASTER
            done
        fi

        if [ -n "$defgw" ] ; then
            if ! ip -4 route | grep "^default.*$MASTER" ; then
                route add default gw $defgw $MASTER
            fi
        fi
    fi
}

ClearBondingIf()
{
    local MASTER=$1
    if [ -n "$MASTER" ] ; then
        /usr/sbin/ip link set $MASTER down
        for SLAVE in $(cat /sys/class/net/$MASTER/bonding/slaves) ; do
            RemoveBondingSlave $MASTER $SLAVE
        done
        echo "-$MASTER" > /sys/class/net/bonding_masters
    fi
}

UpdateBondingInterface()
{
    local INTERFACE=$1
    local RATE=$2
    local XMIT=$3
    # create bonding interface if it doesn't exist
    EXISTING_BONDS=$(cat /sys/class/net/bonding_masters)
    echo " $EXISTING_BONDS " | grep " $INTERFACE " >/dev/null
    if [ $? -gt 0 ] ; then
        echo "+$INTERFACE" >/sys/class/net/bonding_masters
    else
        echo "bonding interface $INTERFACE exits"
    fi

    # check if interface exist now
    if [ -d /sys/class/net/$INTERFACE ] ; then
        # 802.3ad
        local cidrs=$(ip -4 addr show $INTERFACE | grep "^    inet .* $INTERFACE" | awk '{print $2}')
        local defgw=$(ip -4 route | grep "^default.*$INTERFACE" | awk '{print $3}')

        ip link set $INTERFACE down

        echo 4 >/sys/class/net/$INTERFACE/bonding/mode
        echo 100 >/sys/class/net/$INTERFACE/bonding/miimon
        echo $RATE >/sys/class/net/$INTERFACE/bonding/lacp_rate
        echo $XMIT >/sys/class/net/$INTERFACE/bonding/xmit_hash_policy

        ip link set $INTERFACE up

        if ! ip -4 addr show $INTERFACE | grep -q "inet" ; then
            for cidr in $cidrs ; do
                ip -4 addr add $cidr dev $INTERFACE
            done
        fi

        if [ -n "$defgw" ] ; then
            if ! ip -4 route | grep "^default.*$INTERFACE" ; then
                route add default gw $defgw $INTERFACE
            fi
        fi
        return 0
    else
        echo "Creation of bonding interface $INTERFACE failed"
        return -1;
    fi
}

AddBondingSlave()
{
    local MASTER=$1
    local SLAVE=$2
    for i in 1 2 3 4 5 6 7 8 9 10 ; do
        local BONDING_SLAVES=$(cat /sys/class/net/$MASTER/bonding/slaves)
        echo " $BONDING_SLAVES " | grep " $SLAVE " >/dev/null
        if [ $? -eq 0 ] ; then
            break
        else
            /usr/sbin/ip link set $SLAVE down
            sleep 1
            echo "+$SLAVE" > /sys/class/net/$MASTER/bonding/slaves
            sleep 1
        fi
    done
}

RemoveBondingSlave()
{
    local MASTER=$1
    local SLAVE=$2
    for i in 1 2 3 4 5 6 7 8 9 10 ; do
        local BONDING_SLAVES=$(cat /sys/class/net/$MASTER/bonding/slaves)
        echo " $BONDING_SLAVES " | grep " $SLAVE " >/dev/null
        if [ $? -gt 0 ] ; then
            break
        else
            /usr/sbin/ip link set $SLAVE down
            sleep 1
            echo "-$SLAVE" > /sys/class/net/$MASTER/bonding/slaves
            sleep 1
        fi
    done
}

ClearVlanConfig()
{
    local VIF=$1
    if [ -n "$VIF" ] ; then
        ip link set $VIF down
        ip link delete $VIF
    fi
}

UpdateVlanInterface()
{
    local MASTER=$1
    local VID=$2
    if [ -n "$MASTER" ] ; then
        ip link set $MASTER up
        ip link add link $MASTER name $MASTER.$VID type vlan id $VID
    fi
}

AddUpdateHistory()
{
    local HISTORY_FILE=/var/appliance-db/update.history

    local RELEASE=$(cat $1)
    local TYPE=$2
    local IMAGE=$(echo $RELEASE | awk -F'_' '{print $1}')
    local VERSION=$(echo $RELEASE | awk -F'_' '{print $2}')
    local BLD_TIME=$(echo $RELEASE | awk -F'_' '{print $3}')
    local VARIANT=$(echo $RELEASE | awk -F'_' '{print $4}')
    local NOW=$(date +"%Y%m%d-%H%M TZ:%z")

    # in YAML format
    if [ ! -f "$HISTORY_FILE" ] ; then
        echo "---" > $HISTORY_FILE
        echo "# file: /var/appliance-db/update.history" >> $HISTORY_FILE
        echo "" >> $HISTORY_FILE
        echo "current: \"$VERSION\"" >> $HISTORY_FILE
        echo "rollback: \"$VERSION\"" >> $HISTORY_FILE
        echo "history:" >> $HISTORY_FILE
    fi

    echo "  -" >> $HISTORY_FILE
    echo "    image: \"$IMAGE\"" >> $HISTORY_FILE
    echo "    type: \"$TYPE\"" >> $HISTORY_FILE
    echo "    version: \"$VERSION\"" >> $HISTORY_FILE
    echo "    variant: \"$VARIANT\"" >> $HISTORY_FILE
    echo "    built-at: \"${BLD_TIME} TZ:+0000\"" >> $HISTORY_FILE
    echo "    created-at: \"$NOW\"" >> $HISTORY_FILE
}

# params:
# $1: fixpack path (required)
FixpackList()
{
    local DIR=$1

    cd $DIR
    ls -la *.fixpack 2>/dev/null | awk '{print $9}'
    ls -la */*.fixpack 2>/dev/null | awk '{print $9}'
}

# params:
# $1: previous dir (required)
EtcShadowMigrate()
{
    local PREV_DIR=$1
    local root_line=$(cat $PREV_DIR/etc/shadow | grep root:)
    local admin_line=$(cat $PREV_DIR/etc/shadow | grep admin:)
    if sed "s~^root:.*~$root_line~g" /etc/shadow >/dev/null 2>&1 ; then
        sed -i "s~^root:.*~$root_line~g" /etc/shadow
    else
        echo "failed to migrate root account" >> /var/log/migrate.log
    fi
    if sed "s~^admin:.*~$admin_line~g" /etc/shadow >/dev/null 2>&1 ; then
        sed -i "s~^admin:.*~$admin_line~g" /etc/shadow
    else
        echo "failed to migrate admin account" >> /var/log/migrate.log
    fi
}

DumpInterface()
{
    local wait_sec=${1:-8}
    touch /etc/settings.sys
    source hex_tuning /etc/settings.sys sys.net.if

    if [ -n "$VERBOSE" ] ; then
        printf "%120s\n" " " | tr " " "-"
        printf "%8s %8s %16s %14s %20s %10s %5s %6s %s\n" "Dev" "Label" "DevID/Cfg" "BusID/Slaves" "HWAddr" "Driver" "Link" "State" "Speed(actual/advertised)"
        printf "%120s\n" " " | tr " " "-"
    else
        printf "%61s\n" " " | tr " " "-"
        printf "%8s %14s %10s %6s %12s\n" "Label" "BusID/Slaves" "Driver" "State" "Speed"
        printf "%61s\n" " " | tr " " "-"
    fi

    I=0
    FAILED=0
    declare -A ORIG_STATE=()
    while true ; do
        eval HWADDR=\${T_sys_net_if_mac_eth${I}}
        if [ -z "$HWADDR" ] ; then
            I=$(expr $I + 1)
            FAILED=$(expr $FAILED + 1)
            if [ $FAILED -gt 10 ] ; then
                break
            else
                continue
            fi
        fi
        if /usr/sbin/ethtool eth$I >/dev/null 2>&1 ; then
            if cat /sys/class/net/eth$I/carrier >/dev/null 2>&1 ; then
                ORIG_STATE[$I]="UP"
            else
                /usr/sbin/ip link set eth$I up >/dev/null 2>&1
                ORIG_STATE[$I]="DOWN"
                for S in $(seq $wait_sec) ; do
                    SPEED=$(cat /sys/class/net/eth$I/speed 2>/dev/null)
                    [ "x$SPEED" = "x" ] || break
                    sleep 1
                done
            fi
        fi
        I=$(expr $I + 1)
    done

    I=0
    FAILED=0
    while true ; do
        eval HWADDR=\${T_sys_net_if_mac_eth${I}}
        if [ -z "$HWADDR" ] ; then
            I=$(expr $I + 1)
            FAILED=$(expr $FAILED + 1)
            if [ $FAILED -gt 10 ] ; then
                break
            else
                continue
            fi
        fi
        eval LABEL=\${T_sys_net_if_label_eth${I}}
        eval DRIVER=\${T_sys_net_if_driver_eth${I}}
        eval BUSID=\${T_sys_net_if_businfo_eth${I}}
        eval VNDID=\${T_sys_net_if_vendor_eth${I}}
        eval DEVID=\${T_sys_net_if_device_eth${I}}
        if /usr/sbin/ethtool eth$I >/dev/null 2>&1 ; then
            LINK=$(/usr/sbin/ethtool eth$I 2>/dev/null | grep "Link detected:" | awk '{print $3}')
            SPEED=$(/usr/sbin/ethtool eth$I 2>/dev/null | grep "Speed:" | awk {'print $2'} | sed 's/.\{4\}$//')
            DUPLEX=$(/usr/sbin/ethtool eth$I 2>/dev/null | grep "Duplex:" | awk '{print substr ($2, 0, 1)}')
            ADVERTISED=$(/usr/sbin/ethtool eth$I 2>/dev/null | sed -ne '/Advertised link modes:/,/:/p' | sed -e 's/.*://' -e 's/^[[:space:]]*//' -e '$d' | tr " " "\n" | sort -n | tail -1 | sed 's/base.*//')
            if [ "$SPEED" == "Unkn" ] ; then
                SPEED="NA"
                DUPLEX=""
            fi
            if [ "$LINK" == "yes" ] ; then
                if [ -z $SPEED ] ; then
                    # For para-virtual driver, we assume the speed is 1000
                    SPEED=1000
                fi
                if [ -z $DUPLEX ] ; then
                    # For para-virtual driver, we assume it is full duplex
                    DUPLEX="F"
                fi
            fi
            STATE=${ORIG_STATE[$I]}
            if [ "$STATE" == "DOWN" ] ; then
                /usr/sbin/ip link set eth$I down >/dev/null 2>&1
            fi
        else
            LINK="NA"
            SPEED="NA"
            DUPLEX=""
            STATE="NA"
        fi
        if [ -n "$VERBOSE" ] ; then
            printf "%8s %8s %16s %14s %20s %10s %5s %6s %18s\n" "eth$I" "$LABEL" "${VNDID}.${DEVID}" "$BUSID" "$HWADDR" "$DRIVER" "$LINK" "$STATE" "${SPEED}${DUPLEX}/${ADVERTISED}${DUPLEX:-F}"
        else
            printf "%8s %14s %10s %6s %18s\n" "$LABEL" "$BUSID" "$DRIVER" "$STATE" "${SPEED}${DUPLEX}/${ADVERTISED}${DUPLEX:-F}"
        fi
        I=$(expr $I + 1)
    done

    for bond in $(ls /sys/class/net/*/bonding/slaves 2>/dev/null | awk -F'/' '{print $5}') ; do
        if /usr/sbin/ethtool $bond >/dev/null 2>&1 ; then
            LINK=$(/usr/sbin/ethtool $bond 2>/dev/null | grep "Link detected:" | awk '{print $3}')
            SPEED=$(/usr/sbin/ethtool $bond 2>/dev/null |grep "Speed:" |awk {'print $2'} |sed 's/.\{4\}$//')
            DUPLEX=$(/usr/sbin/ethtool $bond 2>/dev/null | grep "Duplex:" | awk '{print substr ($2, 0, 1)}')
            HWADDR=$(cat /sys/class/net/$bond/address 2>/dev/null)
            SLAVES=$(cat /proc/net/bonding/$bond 2>/dev/null | grep -i "slave interface" | awk '{print $3}' | tr '\n' ',')
            RATE=$(cat /sys/class/net/$bond/bonding/lacp_rate | awk '{print $1}')
            XMIT=$(cat /sys/class/net/$bond/bonding/xmit_hash_policy | awk '{print $1}')
            if [ "$SPEED" == "Unkn" ] ; then
                SPEED="NA"
                DUPLEX=""
            fi
            if [ "$LINK" == "yes" ] ; then
                if [ -z $SPEED ] ; then
                    # For para-virtual driver, we assume the speed is 1000
                    SPEED=1000
                fi
                if [ -z $DUPLEX ] ; then
                    # For para-virtual driver, we assume it is full duplex
                    DUPLEX="F"
                fi
            fi
            STATE="DOWN"
            (cat /sys/class/net/$bond/carrier >/dev/null 2>&1) && STATE="UP"
        else
            LINK="NA"
            SPEED="NA"
            DUPLEX=""
            STATE="NA"
        fi
        if [ -n "$VERBOSE" ] ; then
            printf "%8s %8s %16s %14s %20s %10s %5s %6s %18s\n" "$bond" "$bond" "${RATE},${XMIT}" "${SLAVES::-1}" "$HWADDR" "802.3ad" "$LINK" "$STATE" "${SPEED}${DUPLEX}/bonded"
        else
            printf "%8s %14s %10s %6s %18s\n" "$bond" "${SLAVES::-1}" "802.3ad" "$STATE" "${SPEED}${DUPLEX}/bonded"
        fi
    done

    if [ -n "$VERBOSE" ] ; then
        printf "%120s\n" " " | tr " " "-"
    else
        printf "%61s\n" " " | tr " " "-"
    fi
}

DumpDisk()
{
    /bin/lsblk -d --sort name -o NAME,SIZE,MODEL,TRAN,ROTA
}

GetKernelCmdLine()
{
    local key=$1
    local value=$(cat /proc/cmdline | grep -o "$key=[^ ]*" | awk -F'=' '{print $2}' )
    echo -n "$value"
}

FindIfnameById()
{
    local id=$1

    for ether in $(ls /sys/class/net/*/device/uevent) ; do
        local ifname=$(echo $ether | awk -F'/' '{print $5}')
        local pciid=$(cat $ether | grep PCI_SLOT_NAME | awk -F'=' '{print $2}')
        if [ -n "$pciid" -a "$pciid" == "$id" ] ; then
            echo -n "$ifname"
            break
        fi
    done
}

FetchPxeCfg()
{
    local url=$1
    # proto://endpoint/path
    local proto=$(echo $url | awk -F':' '{print $1}')
    local endpoint=$(echo $url | awk -F '//' '{print $2}' | awk -F'/' '{print $1}')
    local path=$(echo $url | awk -F '//' '{print $2}' | cut -d '/' -f2- | tr -d '\n')
    rm -f /tmp/pxe.cfg
    if [ "$proto" == "http" ] ; then
        /usr/bin/wget -q -O /tmp/pxe.cfg $url
    elif [ "$proto" == "tftp" ] ; then
        (cd /tmp && /usr/bin/tftp -m binary $endpoint -c get $path)
    fi
}

ReadPxeCfg()
{
    local key=$1
    if [ -f /tmp/pxe.cfg ] ; then
        local value=$(cat /tmp/pxe.cfg | grep $key | awk -F'=' '{print $2}')
        if [ -n "$value" ] ; then
            echo -n "$value"
        fi
    fi
}

GetParentIfname()
{
    local pIf=$(ls -la /sys/class/net/$1/upper_* 2>/dev/null | awk -F'/' '{print $NF}')
    if [ -S /var/run/openvswitch/db.sock ] ; then
        if [ -z "$pIf" ] ; then
            pIf=$(/usr/bin/ovs-vsctl port-to-br $1 2>/dev/null)
        elif grep -q "ovs-system" <<< "$pIf" ; then
            pIf=$(/usr/bin/ovs-vsctl port-to-br $1 2>/dev/null)
        fi
    fi
    echo -n "${pIf:-$1}"
}

GetDeviceDriver()
{
    dev=$(readlink -m $1)

    # test for block/character device
    if [ -b "$dev" ] ; then
        mode=block
    elif [ -c "$dev" ] ; then
        mode=char
    else
        echo "$dev is not a device file" >&2
        exit 1
    fi

    # stat outputs major/minor in hex, convert to decimal
    data=$(stat -c '%t %T' $dev) || exit 2
    major=$(echo $data | awk '{print $1}')
    minor=$(echo $data | awk '{print $2}')

    echo -e "Given device:     $1"
    echo -e "Canonical device: $dev"
    echo -e "Major: $major"
    echo -e "Minor: $minor\n"

    # sometimes nodes have been created for devices that are not present
    dir=$(readlink -f /sys/dev/$mode/$major\:$minor)
    if ! [ -e "$dir" ] ; then
        echo "No /sys entry for $dev" >&2
        exit 3
    fi

    # walk up the /sys hierarchy one directory at a time
    # stop when there are three levels left
    while [[ $dir == /*/*/* ]] ; do

        # it seems the directory is only of interest if there is a 'uevent' file
        if [ -e "$dir/uevent" ] ; then
            echo "$dir:"
            echo "  Uevent:"
            sed 's/^/    /' "$dir/uevent"

            # check for subsystem link
            if [ -d "$dir/subsystem" ] ; then
                subsystem=$(readlink -f "$dir/subsystem")
                echo -e "\n  Subsystem:\n    ${subsystem##*/}"
            fi

            echo
        fi

        # strip a subdirectory
        dir=${dir%/*}
    done
}

RootfsEnableDns()
{
    cp -f /etc/resolv.conf $ROOTDIR/etc/
}

RootfsDisableDns()
{
    CLEANUP="$CLEANUP $ROOTDIR/etc/resolv.conf"
}

# bind mount host folder to rootfs/folder
# RootfsBind $RPMDIR $ROOTDIR/RPMS
RootfsBind()
{
    mkdir -p $1 $ROOTDIR/$2 && mount --bind $1 $ROOTDIR/$2
    mount -t proc proc $ROOTDIR/proc
}

# RootfsUnbind $ROOTDIR/RPMS
RootfsUnbind()
{
    umount $ROOTDIR/$1 && rmdir $ROOTDIR/$1
    umount $ROOTDIR/proc
}

# RootfsEnableProxy $ROOTDIR
RootfsEnableProxy()
{
    if timeout 5 curl -x $HEX_PROXY_URL ifconfig.co >/dev/null 2>&1 ; then
        export http_proxy=$HEX_PROXY_URL
        export https_proxy=$HEX_PROXY_URL
        if [ "x$PROG" = "xinstallpip" ] ; then
            OPTIONS+=" --proxy $HEX_PROXY_URL"
        elif [ "x$PROG" = "xinstalldnf" ] ; then
            ! grep -q "^proxy=" $ROOTDIR/etc/dnf/dnf.conf || sed -i '/^proxy=/d' $ROOTDIR/etc/dnf/dnf.conf
            echo "proxy=$HEX_PROXY_URL" >> $ROOTDIR/etc/dnf/dnf.conf
        fi
    fi
}

# RootfsDisableProxy $ROOTDIR
RootfsDisableProxy()
{
    export http_proxy=
    export https_proxy=
    if [ "x$PROG" = "xinstallpip" ] ; then
        unset OPTIONS
    elif [ "x$PROG" = "xinstalldnf" ] ; then
        ! grep -q "^proxy=" $ROOTDIR/etc/dnf/dnf.conf || sed -i '/^proxy=/d' $ROOTDIR/etc/dnf/dnf.conf
    fi
}

NetbootInterfaceCfg()
{
    local ifname=$1
    local orig=$(cat /tmp/netboot_interface | tr -d '\n')
    /usr/sbin/ip link set $orig down
    ifconfig $ifname 192.168.1.150 netmask 255.255.255.0 up
    echo "$ifname" > /tmp/netboot_interface
}

CreateSwap()
{
    local STORE="/store"
    local SWAPFILE="${STORE}/.swap"
    local FREESPACE=$(ConvertImageSize $(df $STORE --block-size=K --output=size --sync | grep -v "1K-blocks"))
    local SWAPSIZEK=0
    local SWAPSIZEM=0
    local ISNUM='^[0-9]+$'

    if ! [[ $FREESPACE =~ $ISNUM ]] ; then echo "Bad free space value: $FREESPACE" && return ; fi

    if [ $FREESPACE -gt $(ConvertImageSize 40G) ] ; then
        SWAPSIZEK=$(ConvertImageSize 40G)
    elif [ $FREESPACE -gt $(ConvertImageSize 30G) ] ; then
        SWAPSIZEK=$(ConvertImageSize 30G)
    elif [ $FREESPACE -gt $(ConvertImageSize 20G) ] ; then
        SWAPSIZEK=$(ConvertImageSize 20G)
    elif [ $FREESPACE -gt $(ConvertImageSize 10G) ] ; then
        SWAPSIZEK=$(ConvertImageSize 10G)
    else
        SWAPSIZEK=$(( $FREESPACE - $(ConvertImageSize 1G) ))
    fi

    if [ -e $SWAPFILE ] ; then
        echo "swap file ($SWAPFILE) already exists"
    else
        free -g
        SWAPSIZEM=$(( $SWAPSIZEK / 1024 ))
        dd if=/dev/zero of=$SWAPFILE bs=1M count=$SWAPSIZEM
        chmod 0600 $SWAPFILE
        mkswap $SWAPFILE
        swapoff -a
        SUF=$(date '+%Y%m%d')
        [ -e /etc/fstab.$SUF ] || cp /etc/fstab /etc/fstab.$SUF
        sed /swap.*swap/d /etc/fstab.$SUF > /etc/fstab
        echo "$SWAPFILE                                  swap    swap     defaults   0 0" >> /etc/fstab
        grep -q swapon /etc/rc.mount || echo "/sbin/swapon -a" >> /etc/rc.mount
        source /etc/rc.mount
    fi
    free -g
}

DeleteSwap()
{
    local STORE="/store"
    local SWAPFILE="${STORE}/.swap"

    swapoff -a && rm -f $SWAPFILE
    SUF=$(date '+%Y%m%d')tmp
    cp -f /etc/fstab /etc/fstab.$SUF
    sed /swap.*swap/d /etc/fstab.$SUF > /etc/fstab
    rm -f /etc/fstab.$SUF

    cp -f /etc/rc.mount /etc/rc.mount.$SUF
    sed /.*swapon.*/d /etc/rc.mount.$SUF > /etc/rc.mount
    rm -f /etc/rc.mount.$SUF
}

IsVersionOlder()
{
    [ "$1" = "$2" ] && return 1
    printf '%s\n%s' "$1" "$2" | sort -C -V
}

dedup_sshauthkey()
{
    local auth_keys=/root/.ssh/authorized_keys
    [ ! -e "$auth_keys" ] || awk -i inplace '!seen[$0]++' $auth_keys
}

# Get disk age in hours
# Usage: GetDiskHour <dev>
GetDiskHour()
{
    local DEVICE=$1
    smartctl -A $DEVICE | grep -i Power_On_Hours | awk '{print $NF}'
}

# Get disk err count
# Usage: GetDiskErrCt <dev>
GetDiskErrCt()
{
    local DEVICE=$1
    smartctl -A $DEVICE | grep -i Reallocated_Sector_Ct | awk '{print $NF}'
}
